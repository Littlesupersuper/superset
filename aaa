import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.locks.ReentrantLock;

@Service
public class CustomQueueService {

    private final LinkedBlockingQueue<String> queue = new LinkedBlockingQueue<>();
    private final ReentrantLock lock = new ReentrantLock();
    private final RestTemplate restTemplate = new RestTemplate();
    private volatile boolean running = true;

    // 初始化消费者线程
    public CustomQueueService() {
        startConsumer();
    }

    // 添加数据到队列
    public void addData(String data) {
        lock.lock();
        try {
            queue.offer(data); // 添加数据到队列
        } finally {
            lock.unlock();
        }
    }

    // 消费者线程
    private void startConsumer() {
        Thread consumerThread = new Thread(() -> {
            while (running || !queue.isEmpty()) {
                try {
                    // 从队列中取出数据
                    String data = queue.take();
                    sendHttpRequest(data); // 发送 HTTP 请求
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
        consumerThread.setDaemon(true); // 设置为守护线程
        consumerThread.start();
    }

    // 发送 HTTP 请求
    private void sendHttpRequest(String data) {
        String targetUrl = "http://example.com/endpoint"; // 目标服务 URL
        try {
            // 根据需要修改请求逻辑
            String response = restTemplate.postForObject(targetUrl, data, String.class);
            System.out.println("发送成功: " + response);
        } catch (Exception e) {
            System.err.println("发送失败: " + e.getMessage());
        }
    }

    // 停止消费者线程
    public void stopService() {
        running = false;
    }
}